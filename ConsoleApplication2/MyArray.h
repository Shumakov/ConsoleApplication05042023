#pragma once
// Пример класса

void test();

// Класс-обертка над массивом целочисленных переменных
// Заголовочный файл с описанием класса 
class MyArray{
	int* mass{}; // массив
	unsigned int size{}; //  размер массива
public:

	// Конструктор, если  при создании экземпляра не передавать аргументов
	// то будет создан массив из 10 элементов и такой конструктор является еще
	//  реализацией конструктора по умолчанию
	explicit MyArray(unsigned int size = 10);

	// Конструктор копирования т.к. в классе используется работа с динамической памятью
	//  то необходима реализация этого конструктора с механизмом глубокого копирования
	MyArray(const MyArray& a);

	// Конструктор перемещения, вызывается для копирования временных обьектов
	// В нем отсутствует глубокое коприрование
	MyArray(MyArray&& a);

	// Деструктор
	~MyArray();

	//  Функции-члены для покрытия некого функционала. Имена функций должны
	// говорить о их функциональности
	void gen();
	void print() const;
	int search(int key) const;
	void set(unsigned int ind, int value);
	int get(unsigned int ind);

	unsigned int getSize() const {
		return size;
	}

	// Блок прототипов перегрузки операторов дружественными функциями

	//  Перегрузка оператора для работы с стандартным потоком вывода
	// возвращает ссылку на поток для возможности организации цепочки вызовов
	friend std::ostream& operator<< (std::ostream& o, const MyArray& m);

	// Перегрузка оператора +, оба операнда эеземпляры нашего класса
	// возвращает новый элемент
	friend MyArray operator+ (const MyArray& a, const MyArray& b);
	// MyArray operator+ (const MyArray& b);


	// Перегрузка оператора +, левый операнд -  эеземпляр нашего класса
	// правый операнд - целочисленная переменная
	// возвращает новый элемент
	friend MyArray operator+ (const MyArray& a, int b);

	// Перегрузка оператора +, левый операнд = целочисленная переменная,
	// правый операнд - экземпляр нашего класса
	// возвращает целочисленную переменную
	friend int operator+ (int a, const MyArray& b );

	//  Оператор ==, сравнивает два экземпляра нашего класса на полное их соответствие
	// возвращает логическую переменную
	friend bool operator== (const MyArray& a, const MyArray& b);
	// Конец блока прототипов перегрузки операторов дружественными функциями


	// Перегрузка операторов функциями-членами класса
	// осоь=бенностью является то, что не описывается левый операнд
	// он автоматически будет заменен на this

	// Оператор = (копирующего приравнивания)
	// реализация необходима из=за того, что в классе ведется
	// работа с динамической памятью
	MyArray& operator= (const MyArray& a);

	// Оператор = (перемещающего приравнивания)	
	// Не происходит глубокого копирования
	MyArray& operator= (MyArray&& a);

	// Оператор += (сокращенное сложение)
	MyArray& operator+= (const MyArray& b);

	int operator[] (unsigned int) const;
	int& operator[] (unsigned int);

	//friend std::istream& operator>> (std::istream& o, MyArray& m);
};

